---
title: "Stat 341, Homework 1"
author: "Name1 and Name2 and Name3"
date: '2018-01-15'
output: html_document
Submitted: Chun Wai, karl, Ng Trevor Tong
Student ID: 301139833 301216523
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We will work with the `gapminder` data 
and will use functions from `dplyr` for this homework.
The `gapmider` dataset is a `tbl_df` data structure, 
which 
we will coerce to a `data.frame`.

```{r, warning=FALSE, message=FALSE}
library(gapminder); library(dplyr)
gapminder <- as.data.frame(gapminder)
```

1. (1 mark)
Write a code chunk that uses the basic `[`, `[[` or `$`
operators to extract all data 
from Canada and the United States and saves them as a new
dataset called `CanUS1`. 

_Answer_
`CanUS1 = subset(gapminder , gapminder$country == c("Canada" , "United States"))`

2. (3 marks)
Repeat the subsetting in (1) with the `filter()` function
from `dplyr` to create a dataset `CanUS2`. 
Verify column-by-column that all elements of `CanUS1` and
`CanUS2` equal using the `all.equal()` function and 
a `for` loop over columns. 
What difference does `all.equal(CanUS1,CanUS2)` report?

_Answer_
```
CanUS2 = filter(gapminder , gapminder$country == c("Canada" , "United States"))

result1 = all.equal(CanUS1 , CanUS2)

m = dim(gapminder)[2]
for (i in 1:m){
  print(CanUS1[i] == CanUS2[i])
}
```
so they are the same

3. (2 marks)
Extract the columns `year`, `lifeExp`, `pop` and 
`gdpPercap` from the original `gapminder`
dataset and save as `gm2` (1 mark). 
Also coerce `gm2` to a matrix and save as `gm3` (1 mark).

_Answer_
```
gm2 = gapminder[3:6]
gm3 = matrix(c(gm2$year , gm2$lifeExp , gm2$pop , gm2$gdpPercap) , ncol = 4)
```

4. (2 marks)
Create a larger dataset by stacking `gm2`
`n=100` times over. That is, if `nrg` is the number
of rows of `gm2` and `ncg` is the number of columns,
the larger dataset should have `100*nrg` rows and
`ncg` columns.
Call your stacked dataset `biggm2`. 
To create the stacked dataset, 
initialize with `biggm2 <- NULL` and use 
a `for` loop to build up `biggm2` one layer 
at a time. Time this code using the `system.time()` function.
An example use of `system.time()` to time an R 
command, e.g., `x <- rnorm(100000)` is:
```{r}
system.time({
  x <- rnorm(100000) # Could put multiple lines of R code here
})
```
Use the first element of the output (`user` time) as 
your measure of execution time.

```
_Answer_
biggm2 = ""
system.time({
  for (i in 1:100){
    biggm2 = rbind(biggm2, gm2)
  }
  
})
```


5. (2 marks)
Repeat (4) to create `biggm3` by stacking `gm3` 100 times,
and compare the timings for constructing `biggm2` versus
`biggm3`.

_Answer_
```
biggm3 = ""
t2 = system.time({
  for (i in 1:100){
    biggm3 = rbind(biggm3, gm3)
  }
  
})
td = abs(t1[1]-t2[1]) 
```
Time difference = 4.412 sec - 1.616 sec


6. (3 marks) 
Now build `biggm3` by (i) initializing an empty
matrix of appropriate dimension, and (ii) looping 100 times
and inserting `gm3` into successive layers of `biggm3`.
Time this code and compare the timing to that of 
part (5). You may find the following R function
useful:
```{r}
layerInds <- function(layerNum,nrow) {
  ((layerNum-1)*nrow + 1):(layerNum*nrow) 
}
# Example use:
inds <- layerInds(layer=1,nrow=nrow(gapminder))
range(inds)
```

_Answer_
```
biggm3 = matrix(c("") , ncol = dim(gapminder)[2]*100 , nrow = dim(gapminder)[1]*100)
t3 = system.time({
  for (i in 1:100){
    biggm3 = rbind(biggm3, gm3)
  }
```
The time needed is 3.5sec.

7. (3 marks)
Write a function called `stackmat` that implements the faster
of (5) and (6) for stacking matrices. The function 
should:
    - Take a matrix `mat` as input and the number `nstack` of
    times it is to be stacked, with default number `nstack=1`.
    - Test whether `mat` is a matrix; if not,
    stop execution and issue an error message. 
    For the error, use the `stop()` function, as in
    `stop("argument `mat` must be a matrix")`
    - Stack `mat` `nstack` times and return the result.

Test that your function can replicate the `biggm3` matrix
you created earlier.
  
_Answer_
```
stackmat <- function(mat, nstack){
  if (class(mat) != matrix ){
    stop("argumentmatmust be a matrix")
  }
  intial = ""
  t1 = = system.time({
    for (i in 1:100){
      intial = rbind(intial, mat)
    }
  nullmat = matrix(c("") , ncol = dim(mat)[2]*nstack , nrow = dim(mat)[1]*nstack)
  t2 = system.time({
    for (i in 1:100){
      nullmat = rbind(nullmat, mat)
    }
    max = ""
  if (t1 > t2) {
    max = "5"
  }
  if (t2 > t1) {
    max = "6"
    }
  
    
  })
    
  })
  return(max)
}
```
